# JS面试题

## 1.运算符优先级

JavaScript中的运算符优先级是一套规则。该规则在计算表达式时控制运算符执行的顺序。具有较高优先级的运算符先于较低优先级的运算符执行。例如，乘法的执行先于加法。

下表按从最高到最低的优先级列出JavaScript运算符。具有相同优先级的运算符按从左至右的顺序求值。



| 运算符                             | 描述                                         |
| ---------------------------------- | -------------------------------------------- |
| . [] ()                            | 字段访问、数组下标、函数调用以及表达式分组   |
| ++ -- - ~ ! delete new typeof void | 一元运算符、返回数据类型、对象创建、未定义值 |
| * / %                              | 乘法、除法、取模                             |
| + - +                              | 加法、减法、字符串连接                       |
| << >> >>>                          | 移位                                         |
| < <= > >= instanceof               | 小于、小于等于、大于、大于等于、instanceof   |
| == != === !==                      | 等于、不等于、严格相等、非严格相等           |
| &                                  | 按位与                                       |
| ^                                  | 按位异或                                     |
| \|                                 | 按位或                                       |
| &&                                 | 逻辑与                                       |
| \|\|                               | 逻辑或                                       |
| ?:                                 | 条件                                         |
| = oP=                              | 赋值、运算赋值                               |
| ,                                  | 多重求值                                     |



```
var a = 1,b =2;
console.log(a+++b)  // 3      结束后   a=2`


```

## 2.考察即时函数的执行流程

```
var result = (function(){
return 1;
},function(){
return "2"
})()
console.log(typeof result)    //  string
```





## 3.函数防抖和函数节流

**函数节流和函数防抖，两者都是优化高频率执行js代码的一种手段。**

1. #### **函数节流**

    是指一定时间内js方法只跑一次。比如人的眨眼睛，就是一定时间内眨一次。这是函数节流最形象的解释。

2. 1. **函数节流的要点是，声明一个变量当标志位（开关），记录当前代码是否在执行。**

 **如果空闲，则可以正常触发方法执行。**

 **如果代码正在执行，则取消这次方法执行，直接return。**

#### 2.防抖

1. **函数防抖是指频繁触发的情况下，只有足够的空闲时间，才执行代码一次。比如生活中的坐公交，就是一定时间内，如果有人陆续刷卡上车，司机就不会开车。只有别人没刷卡了，司机才开车。**

2. 1. **函数防抖的应用场景，最常见的就是用户注册时候的手机号码验证和邮箱验证了。只有等用户输入完毕后，前端才需要检查格式是否正确，如果不正确，再弹出提示语。**
   2. **函数防抖的要点，也是需要一个setTimeout来辅助实现。延迟执行需要跑的代码。**

 **如果方法多次触发，则把上次记录的延迟执行代码用clearTimeout清掉，重新开始。**

 **如果计时完毕，没有方法进来访问触发，则执行代码。**

## 4.重绘、回流

**重绘repaint:**当元素的一部分属性发生变化，如外观背景色不会引起布局变化而需要重新渲染的过程叫做**重绘**



**回流reflow**：当render树中的一部分或者全部因为大小边距等问题发生改变而需要重建的过程叫做**回流**



### **什么会引起回流**

这个问题其实很简单，什么引起的，看定义不就可以了？

问题是引起的原因可能会很多

笼统来说当页面的布局和几何属性发生变化的时候就会引起回流。具体来说大概分别5大类：

1.首当其冲自然是dom树结构变化，比如你删除或者添加某个node.

2.元素几何属性变化，包括margin,padding,height,width,border等

3.页面渲染初始化

4.获取某些属性。虽然浏览器引擎可能会针对重排做了优化，比如Opera，它会等到有足够 数量的变化发生，或者等到一定的时间，或者等一个线程结束，再一起处理，这样就只发生一次重排。但除了render树的直接变化，当获取一些属性时，浏览器为取得 正确的值也会触发回流。这样就使得浏览器的优化失效了。这些属性包括：offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、 clientTop、clientLeft、clientWidth、clientHeight、getComputedStyle() (currentStyle in IE)。所以，在多次使用这些值时应进行缓存。（这段我是直接引用的。。。）

5.浏览器窗口发生变化-resize事件发生时

以上，其实理解起来很容易。所谓的render树就是识别了几何属性的dom数，好像我们画人体的时候，dom树是先确定都有什么比如四肢，头部，身体，其他器官等；而render树则是确定这个人的高矮胖瘦，头发是否盖眼睛等，如果我们在绘画过程中发现脖子长了那就惨了，脖子下面都要重画。这就是回流了。如果发现只是手指画的有问题也还是要回流但我们只需要重画手指。（当然，我说的是手就是手，没什么特别造型的时候）；当我们的render树完事了，也就是人体大概轮廓我们都画好了，就可以上色了，换个发色这种我们叫重绘。

```
var s = document.body.style;
s.padding = "2px"; // 回流+重绘
s.border = "1px solid red"; // 再一次 回流+重绘
s.color = "blue"; // 再一次重绘
s.backgroundColor = "#ccc"; // 再一次 重绘
s.fontSize = "14px"; // 再一次 回流+重绘
// 添加node，再一次 回流+重绘
document.body.appendChild(document.createTextNode('abc!'));
```

　　现在我们大概都能得出的结论是：回流比重绘的代价要高，至于具体的花销跟render树有多少节点需要重新构建有关。

　　还有就是，回流一定会伴随着重绘，但是重绘不一定会引起回流。

### **我们要如何避免**

从上面的实例代码中可以看到一共七行代码引起了6次左右的回流、重绘（上面的代码我大老远从别的页面拿过来当然不只是就用那一次，哈哈），而且我们刚刚还知道了回流花销真是不小，那么浏览器是不是真的每次js语句引起了回流他就执行一下呢？恩，后面的内容我是看的参考资料的：等队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会flush队列，进行一个批处理。这样就会让多次的回流、重绘变成一次回流重绘。

但是尽管浏览器挺机智地帮我们优化了代码，我们自己作死也是没救的，比如你去请求

\1. offsetTop, offsetLeft, offsetWidth, offsetHeight

\2. scrollTop/Left/Width/Height

\3. clientTop/Left/Width/Height

\4. width,height

\5. 请求了getComputedStyle(), 或者 IE的 currentStyle

浏览器为了给你返回一个比较精确的答案，他会提前flush队列，因为队列中可能会有影响这些值的操作。

所以我们可以做的是： 

1.将那些改变样式的操作集合在一次完事，直接改变className或者cssText

2.让要操作的元素进行离线处理，处理完事以后再一起更新

（1）使用DocumentFragment进行缓存操作，引发一次回流和重绘



### 课外延伸：

DocumentFragment 节点不属于文档树，继承的 parentNode 属性总是 null。

不过它有一种特殊的行为，该行为使得它非常有用，即当请求把一个 DocumentFragment 节点插入文档树时，插入的不是 DocumentFragment 自身，而是它的所有子孙节点。这使得 DocumentFragment 成了有用的占位符，暂时存放那些一次插入文档的节点。它还有利于实现文档的剪切、复制和粘贴操作。

其实他就是一个游离在DOM树外面的容器，所以你在把它插入文档节点之前，随便给他增删节点都不会引起回流

（2）使用display:none,只引发两次回流和重绘。道理跟上面的一样。因为display:none的元素不会出现在render树

（3）使用cloneNode和replaceChild技术，引发一次回流和重绘（这条其实没太明白）

3.不要经常访问会引起浏览器flush队列的属性，非要高频访问的话建议缓存到变量；

4.将需要多次重排的元素，position属性设为absolute或fixed，这样此元素就脱离了文档流，它的变化不会影响到其他元素。例如有动画效果的元素就最好设置为绝对定位；

5.尽量不要使用表格布局，如果没有定宽表格一列的宽度由最宽的一列决定，那么很可能在最后一行的宽度超出之前的列宽，引起整体回流造成table可能需要多次计算才能确定好其在渲染树中节点的属性，通常要花3倍于同等元素的时间。





# Loadsh  immutable











